#!/usr/bin/env roseus

(setq *rotate-thresh* (deg2rad 10))
(setq *wall-rotate-rad* (deg2rad 10))

(defvar *sp-screenpoint-pub-topic* "/screen_point/input/screenpoint")
(defvar *sp-points-pub-topic* "/screen_point/input/points")
(defvar *sp-sub-topic* "/pointcloud_screenpoint_nodelet/output_point")
(defvar *plane-norm-sub-topic* "/plane_normal_vector/output")
(defvar *interact-sub-topic* "/instruct_info")
(defvar *flag-pub-topic* "/instruct_flag")
(defvar *eyebrows-pub-topic* "/eyebrows_expression/input")

(setq *xyz-uv-req-topic* "/xyz_to_screen_point")

(ros::advertise *sp-screenpoint-pub-topic* geometry_msgs::PointStamped 1)
(ros::advertise *sp-points-pub-topic* sensor_msgs::PointCloud2 1)
(ros::advertise *flag-pub-topic* std_msgs::Bool 1)
(ros::advertise *eyebrows-pub-topic* std_msgs::Int32 1)
(ros::rate 10)

(defun send-robot (wait_time)
  (send *ri* :angle-vector (send *fetch* :angle-vector) wait_time)
  (send *ri* :wait-interpolation)
  )

(defun get-arm-end-pos ()
  (let* ((arm_end_pos))
    (setq arm_end_pos (send (send (send *fetch* :rarm :end-coords) :copy-worldcoords) :pos))
    arm_end_pos)
  )

(defun go-vel-rotate (move_rad)  ;; move_rad[rad] move_time[s]
  (format t "rotate: ~A~%" (rad2deg move_rad))
  (send *ri* :go-velocity 0 0 move_rad)
  (send *ri* :wait-interpolation)
  (ros::duration-sleep 1.0)
  )

(defun go-vel-linear (move_x move_time)  ;; move_x[m] move_time[s]
  (send *ri* :go-velocity (/ move_x move_time) 0 0 (* 1000 move_time) :wait t)
  (send *ri* :wait-interpolation)
  )

(defun make-reset-pose ()
  (send *fetch* :reset-pose)
  (send *fetch* :head :look-at *look-at-pos*)
  (send *fetch* :torso :waist-z :joint-angle *torso-z*)
  (send-robot 4000)
  )

(defun screen-pos-cb (msg)
  (format t "screen-point-cb called~%")
  (setq coords (make-coords :pos (ros::tf-point->pos (send msg :point))))
  (send coords :transform
	(send *tfl* :lookup-transform *base-frame* *camera-frame* (ros::time 0)) :world)
  (setq result_3d_pos (send coords :pos))
  (setq cur_x (elt result_3d_pos 0))
  (when (not (= pre_x cur_x))
    (setq convert_flag 1)
    (setq pre_x cur_x))
  )

(defun convert-2D->3D (x y points_msg)  ;; return flag: 0 if there are not points
  ;; points_msg: pointcloud info
  ;; use pointcloud_screenpoint_nodelet
  ;; result 3D pos: result_3d_pos
  (let* ((x x) (y y) (points_msg points_msg)
	 (pub_xy_msg (instance geometry_msgs::PointStamped :init))
	 (begin_time (ros::time-now))
	 (end_time) (elapsed_time 0))
    (ros::subscribe *sp-sub-topic* geometry_msgs::PointStamped #'screen-pos-cb)
    (send points_msg :header :stamp (ros::time-now))  ;; to sync
    (send pub_xy_msg :header :stamp (ros::time-now))
    (send pub_xy_msg :header :frame_id *camera-frame*)
    (send (send pub_xy_msg :point) :x x)
    (send (send pub_xy_msg :point) :y y)
    (setq convert_flag 0)
    (while (and (= convert_flag 0) (< elapsed_time 5))
      (ros::publish *sp-screenpoint-pub-topic* pub_xy_msg)
      (ros::publish *sp-points-pub-topic* points_msg)
      (ros::spin-once)
      (ros::sleep)
      (setq end_time (ros::time-now))
      (setq elapsed_time (- (send end_time :sec) (send begin_time :sec))))
    (ros::unsubscribe *sp-sub-topic*)
    ))

(defun make-point-msg (x y z)
  (let* ((point_msg (instance geometry_msgs::Point :init))
	 (x x) (y y) (z z))
    (send point_msg :x x)
    (send point_msg :y y)
    (send point_msg :z z)
    point_msg)
  )

(defun convert-2D->point-msg (x y points_msg)
  (let* ((pub_point_msg))
    (convert-2D->3D x y points_msg)
    (format t "~A~%" result_3d_pos)
    (setq pub_point_msg
	  (make-point-msg (elt result_3d_pos 0) (elt result_3d_pos 1) (elt result_3d_pos 2)))
    pub_point_msg)
  )

(defun plane-norm-cb (msg)
  (let* ((poses_msg (send msg :poses)))
    (setq norm_coords_lst '())
    (setq norm_rpy_lst '())
    (when (> (length poses_msg) 0)
      (dotimes (i (length poses_msg))
	(setq pose_msg (elt poses_msg i))
	(setq pos_msg (send pose_msg :position))
	(setq vec_msg (send pose_msg :orientation))
	(setq norm_coords (send (send *tfl* :lookup-transform *base-frame* *camera-frame* (ros::time 0))
				:transform (ros::tf-pose->coords pose_msg)))
	;; (format t "norm_coords: ~A~%" norm_coords)
	;; (format t "pos: ~A, rot: ~A~%" (send norm_coords :pos) (send norm_coords :rot))
	(setq norm_rpy (elt (rpy-angle (send norm_coords :rot)) 0))
	;; (format t "norm_rpy: ~A~%" norm_rpy)
	(setq norm_coords_lst (append norm_coords_lst (list norm_coords)))
	(setq norm_rpy_lst (append norm_rpy_lst (list norm_rpy)))
	))
    ))

(defun get-plane-norm-vec (norm_rpy)
  (let* ((base_box (make-cube 50 50 50))
	 (virtual_box (make-cube 50 50 50))
	 (vbox_pos)
	 (norm_rpy norm_rpy))
    (send virtual_box :locate #f(0 0 500) :world)
    (send base_box :assoc virtual_box)
    (send base_box :newcoords (make-coords :rpy norm_rpy))
    (setq vbox_pos (send (send virtual_box :copy-worldcoords) :pos))
    (list (elt vbox_pos 0) (elt vbox_pos 1) (elt vbox_pos 2)))
  )

(defun select-wall-norm-box (rad)
  (let* ((goal_rad rad) (diff_rad 4) (wall_box_pos nil)
	 (vbox_rad) (norm_rpy) (vbox_pos) (vbox_x) (vbox_y))
    (dotimes (i (length norm_rpy_lst))
      (setq norm_rpy (elt norm_rpy_lst i))
      (setq vbox_pos (get-plane-norm-vec norm_rpy))
      (setq vbox_x (elt vbox_pos 0))
      (setq vbox_y (elt vbox_pos 1))
      (setq vbox_rad (* -1 (atan (/ vbox_y vbox_x))))
      (format t "- ~A pos: ~A rad: ~A~%" i vbox_pos (rad2deg vbox_rad))
      (when (not (and (> (abs goal_rad) (deg2rad 40)) (< (* vbox_rad goal_rad) 0)))
	(when (and (< (abs (- vbox_rad goal_rad)) diff_rad) (> vbox_x 0))
	  (setq diff_rad (abs (- vbox_rad goal_rad)))
	  (setq wall_box_pos vbox_pos)
	  )))
    (format t "vbox_pos: ~A~%" wall_box_pos)
    (format t "~%")
    wall_box_pos)
  )

(defun rotate-ref-box (goal_rad once_rad)
  (let* ((rotate_once_rad once_rad)
	 (ideal_rad goal_rad)
	 (fin_flag 1)
	 (box_rad) (vbox_pos))
    (setq rotate_try_count (+ rotate_try_count 1))
    (setq vbox_pos (select-wall-norm-box goal_rad))
    (when vbox_pos
      (setq box_rad (* -1 (atan (/ (elt vbox_pos 1) (elt vbox_pos 0)))))
      (format t "ideal_rad: ~A, box_rad: ~A~%" (rad2deg ideal_rad) (rad2deg box_rad))
      (when (> (abs (- ideal_rad box_rad)) *rotate-thresh*)
	(if (> (- ideal_rad box_rad) 0)
	    (go-vel-rotate rotate_once_rad)
	  (go-vel-rotate (* -1 rotate_once_rad)))
	(setq fin_flag 0))
      )
    fin_flag)
  )

(defun rotate-ref-wall (goal_rad once_rad)
  (let* ((goal_rad goal_rad) (fin_flag 0)
	 (begin_time (ros::time-now))
	 (elapsed_time 0))
    (setq rotate_try_count 0)
    (setq norm_rpy_lst '())
    (ros::subscribe *plane-norm-sub-topic* geometry_msgs::PoseArray #'plane-norm-cb)
    (while (= fin_flag 0)
      (setq pose_msg nil)
      (setq begin_time (ros::time-now))
      (while (and (not pose_msg) (< elapsed_time 5))
	(ros::spin-once)
	(ros::sleep)
	(setq elapsed_time (- (send (ros::time-now) :sec) (send begin_time :sec))))
      (format t "try_count ~A~%" rotate_try_count)
      (if (and (> (length norm_rpy_lst) 0)
	       (< rotate_try_count 20))
	  (setq fin_flag (rotate-ref-box goal_rad once_rad))
	(setq fin_flag 1))
      (if (= fin_flag 1)
	  (format t "finish rotate~%")))
    (ros::unsubscribe *plane-norm-sub-topic*)
    ))

(defun look-at-wall ()
  (let* ((begin_time (ros::time-now))
	 (elapsed_time 0)
	 (vbox_pos))
    (format t "look at wall~%")
    (setq norm_rpy_lst '())
    (ros::subscribe *plane-norm-sub-topic* geometry_msgs::PoseArray #'plane-norm-cb)
    (setq pose_msg nil)
    (setq begin_time (ros::time-now))
    (while (and (not pose_msg) (< elapsed_time 5))
      (ros::spin-once)
      (ros::sleep)
      (setq elapsed_time (- (send (ros::time-now) :sec) (send begin_time :sec))))
    (when (> (length norm_rpy_lst) 0)
      (setq vbox_pos (select-wall-norm-box 0))
      (when vbox_pos
	(send *fetch* :head :look-at
	      (float-vector (elt vbox_pos 0) (elt vbox_pos 1) (elt *look-at-pos* 2)))
	(send-robot 2000)))
    ))

(defun tf-pose->coords (frame_id pose)
  (send (send *tfl* :lookup-transform *base-frame* frame_id (ros::time 0))
	:transform (ros::tf-pose->coords pose))
  )

(defun bbox->cube (bbox)
  (let* ((dims (ros::tf-point->pos (send bbox :dimensions)))
         (bx (make-cube (elt dims 0) (elt dims 1) (elt dims 2))))
    (send bx :newcoords
          (tf-pose->coords (send bbox :header :frame_id) (send bbox :pose)))
    bx))

(defun view-debug-box (i)
  (setq debug_cube (bbox->cube (elt *bboxes* i)))
  (objects (list *fetch* debug_cube))
  )

(defun bbox->lst (bbox)
  (let* ((coords (tf-pose->coords (send bbox :header :frame_id) (send bbox :pose)))
	 (pos (send coords :pos))
	 (dims (ros::tf-point->pos (send bbox :dimensions))))
    (list coords dims))
  )

(defun convert-3D->2D (xyz_lst)
  ;; *base-frame* 3D pos -> *camera-frame* 2D pos
  (let* ((xyz_req_msg (instance deco_with_fetch::PointStampedRequest :init))
	 (x (elt xyz_lst 0)) (y (elt xyz_lst 1)) (z (elt xyz_lst 2))
	 (input_coords (make-coords :pos (float-vector x y z)))
	 (pos) (coords) (result_msg))
    (setq coords (send (send *tfl* :lookup-transform
			     *camera-frame* *base-frame* (ros::time 0))
		       :transform input_coords))
    (setq pos (send coords :pos))
    (send (send xyz_req_msg :point) :x (elt pos 0))
    (send (send xyz_req_msg :point) :y (elt pos 1))
    (send (send xyz_req_msg :point) :z (elt pos 2))
    (ros::wait-for-service *xyz-uv-req-topic*)
    (setq result_msg (ros::service-call *xyz-uv-req-topic* xyz_req_msg))
    result_msg)
  )

(defun inv-from-reset-pose (target_pos)
  (let* ((ik_res))
    (send *fetch* :reset-pose)
    (setq target_coords (make-coords :pos target_pos))
    (setq ik_res (send *fetch* :inverse-kinematics target_coords))
    (send *fetch* :head :look-at *look-at-pos*)
    ik_res)
  )

(defun get-distance-wall (x y)
  (let* ((x x) (y y) (wall_x) (wall_pcl))
    (ros::duration-sleep 1.0)
    (setq wall_pcl (one-shot-subscribe *head-camera-points*
				       sensor_msgs::PointCloud2 :after-stamp (ros::time-now)))
    (setq result_3d_pos nil)
    (while (not result_3d_pos)
      (convert-2D->3D x y wall_pcl))
    (setq result_3d_pos nil)
    (while (not result_3d_pos)  ;; to get more accurate value
      (convert-2D->3D x y wall_pcl))
    (setq wall_x (elt result_3d_pos 0))
    (format t "wall_x: ~A~%" wall_x)
    wall_x)
  )

(defun view-debug-pos (pos)
  (let* ((vbox (make-cube 50 50 50)))
    (send vbox :locate pos :world)
    (objects (list *fetch* vbox))
  ))

(defun instruct-cb (msg)
  (let* ((count) (message) (flag))
    (setq *instruct-msg* msg)
    (setq count (send *instruct-msg* :called_count))
    (setq message (send *instruct-msg* :message))
    (setq flag (send *instruct-msg* :is_finish))
    (format t "~A: ~A ~A~%" count message flag)
    ))

(defun switch-chat-mode (bool_flag)  ;; true: instruct mode
  (let* ((pub_msg (instance std_msgs::Bool :init)))
    (send pub_msg :data bool_flag)
    (ros::publish *flag-pub-topic* pub_msg)
    ))

(defun publish-eyebrows-expression (pub_int)
  (let* ((pub_msg (instance std_msgs::Int32 :init)))
    (send pub_msg :data pub_int)
    (ros::publish *eyebrows-pub-topic* pub_msg)
    ))

(defun find-boxes-on-wall ()
  (let* ((bboxes_msg) (box_coords_dims)
	 (box_msg) (box_pos) (box_y) (box_z) (box_dims)
	 (boxes_pos_dims_lst '()))
    (ros::duration-sleep 1.0)
    (setq *bboxes* '())
    (setq bboxes_msg (one-shot-subscribe *bounding-box-list*
					 jsk_recognition_msgs::BoundingBoxArray
					 :after-stamp (ros::time-now)))
    (dotimes (i (length (send bboxes_msg :boxes)))
      (setq box_msg (elt (send bboxes_msg :boxes) i))
      (setq box_coords_dims (bbox->lst box_msg))
      (setq box_pos (send (elt box_coords_dims 0) :pos))
      (setq box_dims (elt box_coords_dims 1))
      (setq box_y (elt box_pos 1))
      (setq box_z (elt box_pos 2))
      (when (and (and (and (and (> box_y -800) (< box_y 800)) (< box_z 2000))
		      (and (> (elt box_dims 0) 50) (> (elt box_dims 1) 50)))
		 (and (< (elt box_dims 0) 400) (< (elt box_dims 1) 400)))
	(format t "box_pos: ~A~%" box_pos)
	(setq *bboxes* (append *bboxes* (list box_msg)))
	(setq boxes_pos_dims_lst
	      (append boxes_pos_dims_lst (list (list box_pos (elt box_coords_dims 1)))))
	))
    (when (> (length *bboxes*) 0)
      (when (= (send (send (send (elt *bboxes* 0) :pose) :position) :x) 0)
	(setq *bboxes* '())
	(setq boxes_pos_dims_lst '())))
    boxes_pos_dims_lst)
  )

(defun get-corner-uv (pos dims)
  (let* ((lt_pos) (rt_pos) (lb_pos) (rb_pos)
	 (lt_res) (rt_res) (lb_res) (rb_res)
	 (h_width (/ (elt dims 1) 2.0))
	 (h_length (/ (elt dims 0) 2.0))
	 (h_height (/ (elt dims 2) 2.0)))
    (setq lt_pos (v+ pos (float-vector h_length h_width h_height)))
    (setq rt_pos (v+ pos (float-vector h_length (* -1 h_width) h_height)))
    (setq lb_pos (v+ pos (float-vector (* -1 h_length) h_width h_height)))
    (setq rb_pos (v+ pos (float-vector (* -1 h_length) (* -1 h_width) h_height)))
    (setq lt_res (send (convert-3D->2D lt_pos) :point))
    (setq rt_res (send (convert-3D->2D rt_pos) :point))
    (setq lb_res (send (convert-3D->2D lb_pos) :point))
    (setq rb_res (send (convert-3D->2D rb_pos) :point))
    ;; (format t "xs: ~A~%" (list (send lt_res :x) (send rt_res :x) (send lb_res :x) (send rb_res :x)))
    ;; (format t "ys: ~A~%" (list (send lt_res :y) (send rt_res :y) (send lb_res :y) (send rb_res :y)))
    (list (list (send lt_res :x) (send rt_res :x) (send lb_res :x) (send rb_res :x))
	  (list (send lt_res :y) (send rt_res :y) (send lb_res :y) (send rb_res :y)))
    ))

(defun pointing-pos (target_pos)
  (let* ((pointing_x 600)
	 (pointing_pos (float-vector pointing_x (elt target_pos 1) (elt target_pos 2)))
	 (ik_res nil))
    (while (not ik_res)
      (setq ik_res (inv-from-reset-pose pointing_pos))
      (setq pointing_pos (v+ pointing_pos #f(50 0 0))))
    (send-robot 4000)
    ;; (view-debug-pos target_pos)
    ))
