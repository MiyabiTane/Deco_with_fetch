#!/usr/bin/env roseus

(setq *rotate-thresh* (* pi (/ 10 180.0)))
(setq *wall-rotate-rad* (/ pi 8))

(defvar *sp-screenpoint-pub-topic* "/screen_point/input/screenpoint")
(defvar *sp-points-pub-topic* "/screen_point/input/points")
(defvar *sp-sub-topic* "/pointcloud_screenpoint_nodelet/output_point")
(defvar *plane-norm-sub-topic* "/plane_normal_vector/output")

(ros::advertise *sp-screenpoint-pub-topic* geometry_msgs::PointStamped 1)
(ros::advertise *sp-points-pub-topic* sensor_msgs::PointCloud2 1)
(ros::rate 10)

(defun send-robot (wait_time)
  (send *ri* :angle-vector (send *fetch* :angle-vector) wait_time)
  (send *ri* :wait-interpolation)
  )

(defun get-arm-end-pos ()
  (let* ((arm_end_pos))
    (setq arm_end_pos (send (send (send *fetch* :rarm :end-coords) :copy-worldcoords) :pos))
    arm_end_pos)
  )

(defun go-vel-rotate (move_rad)  ;; move_rad[rad] move_time[s]
  (format t "rotate: ~A~%" (* 180 (/ move_rad pi)))
  (send *ri* :go-velocity 0 0 move_rad)
  (send *ri* :wait-interpolation)
  )

(defun go-vel-linear (move_x move_time)  ;; move_x[m] move_time[s]
  (send *ri* :go-velocity (/ move_x move_time) 0 0 (* 1000 move_time) :wait t)
  (send *ri* :wait-interpolation)
  )

(defun make-reset-pose ()
  (send *fetch* :reset-pose)
  (send *fetch* :head :look-at *look-at-pos*)
  (send *fetch* :torso :waist-z :joint-angle *torso-z*)
  (send-robot 4000)
  )

(defun screen-pos-cb (msg)
  (format t "screen-point-cb called~%")
  (setq coords (make-coords :pos (ros::tf-point->pos (send msg :point))))
  (send coords :transform
	(send *tfl* :lookup-transform *base-frame* *camera-frame* (ros::time 0)) :world)
  (setq result_3d_pos (send coords :pos))
  (setq cur_x (elt result_3d_pos 0))
  (when (not (= pre_x cur_x))
    (setq convert_flag 1)
    (setq pre_x cur_x))
  )

(defun convert-2D->3D (x y points_msg)  ;; return flag: 0 if there are not points
  ;; points_msg: pointcloud info
  ;; use pointcloud_screenpoint_nodelet
  ;; result 3D pos: result_3d_pos
  (let* ((x x) (y y) (points_msg points_msg)
	 (pub_xy_msg (instance geometry_msgs::PointStamped :init))
	 (begin_time (ros::time-now))
	 (end_time) (elapsed_time 0))
    (ros::subscribe *sp-sub-topic* geometry_msgs::PointStamped #'screen-pos-cb)
    (send points_msg :header :stamp (ros::time-now))  ;; to sync
    (send pub_xy_msg :header :stamp (ros::time-now))
    (send pub_xy_msg :header :frame_id *camera-frame*)
    (send (send pub_xy_msg :point) :x x)
    (send (send pub_xy_msg :point) :y y)
    (setq convert_flag 0)
    (while (and (= convert_flag 0) (< elapsed_time 5))
      (ros::publish *sp-screenpoint-pub-topic* pub_xy_msg)
      (ros::publish *sp-points-pub-topic* points_msg)
      (ros::spin-once)
      (ros::sleep)
      (setq end_time (ros::time-now))
      (setq elapsed_time (- (send end_time :sec) (send begin_time :sec))))
    (ros::unsubscribe *sp-sub-topic*)
    ))

(defun make-point-msg (x y z)
  (let* ((point_msg (instance geometry_msgs::Point :init))
	 (x x) (y y) (z z))
    (send point_msg :x x)
    (send point_msg :y y)
    (send point_msg :z z)
    point_msg)
  )

(defun convert-2D->point-msg (x y points_msg)
  (let* ((pub_point_msg))
    (convert-2D->3D x y points_msg)
    (format t "~A~%" result_3d_pos)
    (setq pub_point_msg
	  (make-point-msg (elt result_3d_pos 0) (elt result_3d_pos 1) (elt result_3d_pos 2)))
    pub_point_msg)
  )

(defun plane-norm-cb (msg)
  (let* ((poses_msg (send msg :poses)))
    (setq norm_coords_lst '())
    (setq norm_rpy_lst '())
    (when (> (length poses_msg) 0)
      (dotimes (i (length poses_msg))
	(setq pose_msg (elt poses_msg i))
	(setq pos_msg (send pose_msg :position))
	(setq vec_msg (send pose_msg :orientation))
	(setq norm_coords (send (send *tfl* :lookup-transform *base-frame* *camera-frame* (ros::time 0))
				:transform (ros::tf-pose->coords pose_msg)))
	;; (format t "norm_coords: ~A~%" norm_coords)
	;; (format t "pos: ~A, rot: ~A~%" (send norm_coords :pos) (send norm_coords :rot))
	(setq norm_rpy (elt (rpy-angle (send norm_coords :rot)) 0))
	;; (format t "norm_rpy: ~A~%" norm_rpy)
	(setq norm_coords_lst (append norm_coords_lst (list norm_coords)))
	(setq norm_rpy_lst (append norm_rpy_lst (list norm_rpy)))
	))
    ))

(defun get-plane-norm-vec (norm_rpy)
  (let* ((base_box (make-cube 50 50 50))
	 (virtual_box (make-cube 50 50 50))
	 (vbox_pos)
	 (norm_rpy norm_rpy))
    (send virtual_box :locate #f(0 0 500) :world)
    (send base_box :assoc virtual_box)
    (send base_box :newcoords (make-coords :rpy norm_rpy))
    (setq vbox_pos (send (send virtual_box :copy-worldcoords) :pos))
    (list (elt vbox_pos 0) (elt vbox_pos 1) (elt vbox_pos 2)))
  )

(defun select-wall-norm-box (rad)
  (let* ((wall_box_pos (get-plane-norm-vec (elt norm_rpy_lst 0)))
	 (goal_rad rad) (diff_rad 4) (wall_box_pos)
	 (vbox_rad) (norm_rpy) (vbox_pos) (vbox_x) (vbox_y))
    (dotimes (i (length norm_rpy_lst))
      (setq norm_rpy (elt norm_rpy_lst i))
      (setq vbox_pos (get-plane-norm-vec norm_rpy))
      (setq vbox_x (elt vbox_pos 0))
      (setq vbox_y (elt vbox_pos 1))
      (setq vbox_rad (* -1 (atan (/ vbox_y vbox_x))))
      (format t "- ~A pos: ~A rad: ~A~%" i vbox_pos (* 180 (/ vbox_rad pi)))
      (when (and (< (abs (- vbox_rad goal_rad)) diff_rad) (> vbox_x 0))
	(setq diff_rad (abs (- vbox_rad goal_rad)))
	(setq wall_box_pos vbox_pos)
	))
    (format t "vbox_pos: ~A~%" wall_box_pos)
    (format t "~%")
    wall_box_pos)
  )

(defun rotate-ref-box (rad)
  (let* ((rotate_once_rad *wall-rotate-rad*)
	 (ideal_rad rad)
	 (fin_flag 1)
	 (box_rad) (vbox_pos))
    (setq rotate_try_count (+ rotate_try_count 1))
    (setq vbox_pos (select-wall-norm-box rad))
    (when vbox_pos
      (setq box_rad (* -1 (atan (/ (elt vbox_pos 1) (elt vbox_pos 0)))))
      (format t "ideal_rad: ~A, box_rad: ~A~%"
	      (* 180 (/ ideal_rad pi)) (* 180 (/ box_rad pi)))
      (when (> (abs (- ideal_rad box_rad)) *rotate-thresh*)
	(if (> (- ideal_rad box_rad) 0)
	    (go-vel-rotate rotate_once_rad)
	  (go-vel-rotate (* -1 rotate_once_rad)))
	(setq fin_flag 0))
      )
    fin_flag)
  )

(defun rotate-ref-wall (rad)
  (let* ((rad rad) (fin_flag 0)
	 (begin_time (ros::time-now))
	 (elapsed_time 0))
    (setq rotate_try_count 0)
    (setq norm_rpy_lst '())
    (ros::subscribe *plane-norm-sub-topic* geometry_msgs::PoseArray #'plane-norm-cb)
    (while (= fin_flag 0)
      (setq pose_msg nil)
      (setq begin_time (ros::time-now))
      (while (and (not pose_msg) (< elapsed_time 5))
	(ros::spin-once)
	(ros::sleep)
	(setq elapsed_time (- (send (ros::time-now) :sec) (send begin_time :sec))))
      (format t "try_count ~A~%" rotate_try_count)
      (if (and (> (length norm_rpy_lst) 0)
	       (< rotate_try_count 20))
	  (setq fin_flag (rotate-ref-box rad))
	(setq fin_flag 1))
      (if (= fin_flag 1)
	  (format t "finish rotate~%")))
    (ros::unsubscribe *plane-norm-sub-topic*)
    ))

(defun tf-pose->coords (frame_id pose)
  (send (send *tfl* :lookup-transform *base-frame* frame_id (ros::time 0))
	:transform (ros::tf-pose->coords pose))
  )

(defun bbox->cube (bbox)
  (let* ((dims (ros::tf-point->pos (send bbox :dimensions)))
         (bx (make-cube (elt dims 0) (elt dims 1) (elt dims 2))))
    (send bx :newcoords
          (tf-pose->coords (send bbox :header :frame_id) (send bbox :pose)))
    bx))

(defun view-debug-box (i)
  (setq debug_cube (bbox->cube (elt *bboxes* i)))
  (objects (list *fetch* debug_cube))
  )

(defun bbox->lst (bbox)
  (let* ((coords (tf-pose->coords (send bbox :header :frame_id) (send bbox :pose)))
	 (pos (send coords :pos))
	 (dims (ros::tf-point->pos (send bbox :dimensions))))
    (list coords dims))
  )

(defun inv-from-reset-pose (target_pos)
  (let* ((ik_res))
    (send *fetch* :reset-pose)
    (setq target_coords (make-coords :pos target_pos))
    (setq ik_res (send *fetch* :inverse-kinematics target_coords))
    (send *fetch* :head :look-at *look-at-pos*)
    ik_res)
  )

(defun get-distance-wall (x y)
  (let* ((x x) (y y) (wall_x) (wall_pcl))
    (ros::duration-sleep 1.0)
    (setq wall_pcl (one-shot-subscribe *head-camera-points*
				       sensor_msgs::PointCloud2 :after-stamp (ros::time-now)))
    (setq result_3d_pos nil)
    (while (not result_3d_pos)
      (convert-2D->3D x y wall_pcl))
    ;; (while (not result_3d_pos)  ;; to get more accurate value
    ;;   (convert-2D->3D x y wall_pcl))
    (setq wall_x (elt result_3d_pos 0))
    (format t "wall_x: ~A~%" wall_x)
    wall_x)
  )

(defun view-debug-pos (pos)
  (let* ((vbox (make-cube 50 50 50)))
    (send vbox :locate pos :world)
    (objects (list *fetch* vbox))
  ))

;; -- old func --
(defun select-wall-norm ()  ;; return norm_rpy of wall
  (let* ((center_y 10000) (pos) (abs_y) (wall_num 0))
    (dotimes (i (length norm_coords_lst))
      (setq pos (send (elt norm_coords_lst i) :pos))
      (setq abs_y (abs (elt pos 1)))
      (when (< abs_y center_y)
	(setq center_y abs_y)
	(setq wall_num i)))
    (elt norm_rpy_lst wall_num))
  )
