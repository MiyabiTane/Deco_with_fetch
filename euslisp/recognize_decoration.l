#!/usr/bin/env roseus

(defvar *bounding-box-list* "/segmentation_decomposer/boxes")

(defun find-boxes ()
  (let* ((box_msg) (box_coords) (box_z))
    (setq *bboxes* '())
    (ros::duration-sleep 1.0)
    (setq bboxes_msg (one-shot-subscribe *bounding-box-list*
					 jsk_recognition_msgs::BoundingBoxArray
					 :after-stamp (ros::time-now)))
    (dotimes (i (length (send bboxes_msg :boxes)))
      (setq box_msg (elt (send bboxes_msg :boxes) i))
      (setq box_coords (elt (bbox->lst box_msg) 0))
      (setq box_z (elt (send box_coords :pos) 2))
      ;; ignore box on the floor
      (if (> box_z 300)
	  (setq *bboxes* (append *bboxes* (list box_msg)))
	))
    (when (> (length *bboxes*) 0)
      (if (= (send (send (send (elt *bboxes* 0) :pose) :position) :x) 0)
	  (setq *bboxes* '())))
    ))

(defun calc-mean-pos ()
  (let* ((mean_pos #f(0 0 0))
	 (coords_dims_lst) (pos)
	 (box_num (length *bboxes*)))
    (dotimes (i box_num)
      (setq coords_dims_lst (bbox->lst (elt *bboxes* i)))
      (setq pos (send (elt coords_dims_lst 0) :pos))
      (setq mean_pos (v+ mean_pos
			 (float-vector (elt pos 0) (elt pos 1) (elt pos 2))))
      )
    (setq mean_pos (scale (/ 1.0 box_num) mean_pos))
    mean_pos)
  )

(defun get-center-box-pos ()
  (let* ((coords_dims_lst (bbox->lst (elt *bboxes* 0)))
	 (center_box_pos (send (elt coords_dims_lst 0) :pos))
	 (center_y (elt center_box_pos 1))
	 (box_pos) (pos_y))
    (dotimes (i (length *bboxes*))
      (when (> i 0)
	(setq coords_dims_lst (bbox->lst (elt *bboxes* i)))
	(setq box_pos (send (elt coords_dims_lst 0) :pos))
	(setq pos_y (elt center_box_pos 1))
	(when (< (abs pos_y) (abs center_y))
	  (setq center_y pos_y)
	  (setq center_box_pos box_pos))
	))
    center_box_pos)
  )

(defun find-decoration (look_at_pos)
  (let* ((deco_count 0)
	 (fin_flag 0)
	 (look_at_pos look_at_pos)
	 (center_box_pos))
    (send *fetch* :head :look-at look_at_pos)
    (send-robot 2000)
    (dotimes (i 4)
      (go-vel-rotate (/ pi 4)))
    (while (= fin_flag 0)
      (find-boxes)
      (format t "find ~A boxes~%" (length *bboxes*))
      (when (< (length *bboxes*) deco_count)
	(go-vel-rotate (* -1.0 (/ pi 8)))
	(find-boxes)
	(format t "find ~A boxes~%" (length *bboxes*))
	(setq fin_flag 1))
      (when (= fin_flag 0)
	(setq deco_count (length *bboxes*))
	(go-vel-rotate (/ pi 8)))
      )
    ;; look at center
    (setq center_box_pos (get-center-box-pos))
    (format t "rotate ~A~%" (* 180 (/ (atan (/ (elt center_box_pos 1) (elt center_box_pos 0))) pi)))
    (go-vel-rotate (atan (/ (elt center_box_pos 1) (elt center_box_pos 0))))
    (find-boxes)
    (format t "find ~A boxes~%" (length *bboxes*))
    ))

(defun get-decoration-x ()
  (let* ((deco_x 1000))
    (if (> (length bboxes) 0)
	(setq deco_x (elt (send (elt (bbox->lst (elt bboxes 0)) 0) :pos) 0)))
    (format t "deco_x: ~A~%" deco_x)
    deco_x)
  )

(defun close-decoration (look_at_pos)
  (let* ((fin_flag 0)
	 (deco_count (length *bboxes*))
	 (mean_pos (calc-mean-pos))
	 (look_at_pos look_at_pos))
    (send *fetch* :head :look-at mean_pos)
    (send-robot 2000)
    (find-boxes)
    (if (< (length bboxes) deco_count)
	(progn
	  (send *fetch* :head :look-at look_at_pos)
	  (send-robot 2000)
	  (find-boxes))
      (progn
	(while (= fin_flag 0)
	  (go-vel-linear (/ 100 1000.0) 1)
	  (find-boxes)
	  (setq mean_pos (calc-mean-pos))
	  (send *fetch* :head :look-at mean_pos)
	  (send-robot 2000)
	  (find-boxes)
	  (format t "find ~A boxes, look_at: ~A~%" (length bboxes) mean_pos)
	  (when (or (< (length bboxes) deco_count) (< (get-decoration-x) 1000))
	    (go-vel-linear -100)
	    (send *fetch* :head :look-at look_at_pos)
	    (send-robot 1000)
	    (ros::duration-sleep 1)
	    (find-boxes)
	    (format t "find ~A boxes, look_at: ~A~%" (length *bboxes*) mean_pos)
	    (setq fin_flag 1))
	  (when (= fin_flag 0)
	    (setq deco_count (length *bboxes*))
	    (setq look_at_pos mean_pos))
	  )
	))
    ))

(defun get-deco-image ()
  (let* ((bbox_array_msg (instance jsk_recognition_msgs::BoundingBoxArray :init))
	 (image_raw_msg))
    (setq image_raw_msg (one-shot-subscribe *head-camera-img*
					    sensor_msgs::Image
					    :after-stamp (ros::time-now)))
    (send *dimg-req-msg* :deco_img image_raw_msg)
    ))

(defun recognize-decoration ()
  (let* ((look_at_pos))
    (find-decoration (v- *look-at-pos* #f(0 0 100)))
    ;; (setq look_at_pos (close-decoration (v- *look-at-pos* #f(0 0 100))))
    ;; (get-deco-image)
    ))

  
      
  
