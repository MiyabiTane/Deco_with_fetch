#!/usr/bin/env roseus

(setq *PLACE-POS-OFFSET* #f(1000.0 -313.6 0))  ;; #f(1000 -313.6 0))

(setq *PUSH-TH-1* 0.2)
(setq *PUSH-TH-2* 5.0)  ;; 10.0

(defun push-balloon (thresh1 thresh2 push_x max_count)
  ;; thresh: diff between ideal and real [mm]
  (let* ((diff_x 0)
	 (real_x (elt (get-arm-end-pos) 0))
	 (ideal_x real_x)
	 (diff_wall_x 0)
	 (init_wall_x (get-distance-wall 320 240))
	 (real_wall_x init_wall_x)
	 (try_count 0)
	 (push_x push_x)
	 (instruct_mode_flag nil))
    (switch-chat-mode t)
    (ros::subscribe *interact-sub-topic* deco_with_fetch::InstructInfo #'instruct-cb)
    (when (>= *HUMAN-WILL-VAL* 0.7)
      (send *ri* :speak-jp "この飾り、この辺で良いと思いますか？")
      (format t "この飾り、この辺で良いと思いますか？~%"))
    ;; (look-at-wall)
    (while (and (and (< diff_x thresh1) (< diff_wall_x thresh2))
		(< try_count max_count))
      (when (not (send *instruct-msg* :is_finish))
	(ros::unsubscribe *interact-sub-topic*)
	(if (< *HUMAN-WILL-VAL* 0.7)
	    (setq *HUMAN-WILL-VAL* (min 1.0 (+ *HUMAN-WILL-VAL* 0.2)))
	  (setq *HUMAN-WILL-VAL* (min 1.0 (+ *HUMAN-WILL-VAL* 0.1))))
	(format t "*HUMAN-WILL-VAL* ~A~%" *HUMAN-WILL-VAL*)
	(interact-human-to-robot)
	(when *pass-to-human-flag*
	  (setq try_count (+ max_count 1))))
      (when (not *pass-to-human-flag*)
	(send *fetch* :rarm :move-end-pos (float-vector push_x 0 0) :world)
	(send-robot 1000)
	(setq ideal_x (+ ideal_x push_x))
	(setq real_x (elt (get-arm-end-pos) 0))
	(setq diff_x (- ideal_x real_x))
	(format t "diff_x: ~A~%" diff_x)
	(setq real_wall_x (get-distance-wall 320 240))
	(setq diff_wall_x (- real_wall_x init_wall_x))
	(format t "diff_wall_x ~A~%" diff_wall_x)
	(if (< (- real_wall_x init_wall_x) -500)  ;; remove bug
	    (setq init_wall_x real_wall_x))
	(setq try_count (+ try_count 1))))
    ))

(defun place-balloon-manip (place_pos)
  (let* ((place_pos (float-vector *wall-x* (elt place_pos 1) (elt place_pos 2)))
	 (place_pos (v- place_pos *PLACE-POS-OFFSET*))
	 (move_rot (atan (/ (elt place_pos 1) (elt place_pos 0))))
	 (move_len (norm (v- place_pos (float-vector 0 0 (elt place_pos 2)))))
	 (wall_distance)
	 (arm_end_pos)
	 (torso_z)
	 (rarm_up 0)
	 (push_go_x 0)
	 (push_rotate 0))
    (when (< (elt place_pos 0) 0)
      (setq place_pos (float-vector 10 (elt place_pos 1) (elt place_pos 2)))
      (setq move_rot (atan (/ (elt place_pos 1) (elt place_pos 0))))
      (setq move_len (norm (v- place_pos (float-vector 0 0 (elt place_pos 2))))))
    (format t "~%")
    (format t "== place pos: ~A~%" place_pos)
    (format t "move_rot: ~A, move_len: ~A~%" (rad2deg move_rot) move_len)
    (go-vel-rotate move_rot)
    (rotate-ref-wall move_rot (deg2rad 10))
    (go-vel-linear (/ move_len 1000.0) 2)
    (go-vel-rotate (* -1 move_rot))
    (setq arm_end_pos (get-arm-end-pos))
    ;; (send *fetch* :head :look-at  ;; for rotate-ref-wall
    ;;	  (v+ *look-at-pos* (float-vector 0 (+ (elt arm_end_pos 1) 200) 0)))
    (send *fetch* :head :look-at
	  (float-vector (elt arm_end_pos 0) (elt arm_end_pos 1) (elt *look-at-pos* 2)))
    (send-robot 1000)
    (ros::duration-sleep 0.5)
    (rotate-ref-wall 0.0 (deg2rad 10))
    (send *fetch* :head :look-at  ;; for rotate-ref-wall
	  (v+ *look-at-pos* (float-vector 0 (+ (elt arm_end_pos 1) 200) 0)))
    (setq push_rotate (atan (/ (elt arm_end_pos 1) (elt arm_end_pos 0))))
    (setq torso_z (send *fetch* :torso :waist-z :joint-angle))
    (if (< (- (elt place_pos 2) (elt arm_end_pos 2)) 0)
	(setq rarm_up (- (elt place_pos 2) (elt arm_end_pos 2)))
      (progn
	(if (> (- (elt place_pos 2) (elt arm_end_pos 2)) (- 386.15 torso_z))  ;; max 386.15
	    (setq rarm_up (- (- (elt place_pos 2) (elt arm_end_pos 2)) (- 386.15 torso_z)))
	  (setq rarm_up 0))
	(send *fetch* :torso :waist-z :joint-angle
	      (+ torso_z (- (elt place_pos 2) (elt arm_end_pos 2))))
	(format t "torso z: ~A, torso up ~A~%" torso_z (- (elt place_pos 2) (elt arm_end_pos 2)))
	(send-robot 2000)))
    ;; (setq push_go_x (min 200 (- (get-distance-wall 320 240) 700)))
    (setq push_go_x (- (get-distance-wall 320 240) 700))
    (format t "go_len: ~A~%" push_go_x)
    (go-vel-linear (/ push_go_x 1000.0) 1)
    (format t "rarm_up: ~A~%" rarm_up)
    (send *fetch* :rarm :move-end-pos (float-vector 50 0 rarm_up) :world)
    (send-robot 3000)
    (send *fetch* :rarm :move-end-pos #f(50 0 0) :world)
    (send-robot 1000)
    (push-balloon *PUSH-TH-1* *PUSH-TH-2* 20 15)
    (format t "finish push~%")
    (when (not *pass-to-human-flag*)
      (send *ri* :stop-grasp)
      (send *fetch* :rarm :move-end-pos #f(-20 0 0) :world)
      (send-robot 2000)
      (send *fetch* :rarm :move-end-pos #f(0 0 -150) :world)
      (send-robot 2000)
      (send *fetch* :rarm :move-end-pos #f(-150 0 0) :world)
      (send-robot 2000))
    (list move_len move_rot push_go_x push_rotate))
  )

(defun repush-balloon ()
  (send *fetch* :rarm :move-end-pos #f(0 0 150) :world)
  (send-robot 2000)
  (send *fetch* :rarm :move-end-pos #f(50 0 0) :world)
  (send-robot 2000)
  (push-balloon *PUSH-TH-1* *PUSH-TH-2* 20 3)
  (send *fetch* :rarm :move-end-pos #f(-100 0 0) :world)
  (send-robot 2000)
  (send *fetch* :rarm :move-end-pos #f(-50 0 0) :world)
  (send-robot 2000)
  )

(defun go-back (move_len move_rot push_go_x push_rotate)
  (let* ((move_len (* -1 move_len))
	 (move_rot move_rot)
	 (wall_x)
	 (leave_go_x (min 0 (+ (* -1 push_go_x) 50)))
	 (leave_rotate (* -1 push_rotate)))
    (go-vel-rotate leave_rotate)
    (send *fetch* :head :look-at *look-at-pos*)
    (send-robot 1000)
    (rotate-ref-wall 0.0 (deg2rad 10))
    (go-vel-linear (/ leave_go_x 1000.0) 1)
    (format t "move_len: ~A, move_rot: ~A~%" move_len (rad2deg move_rot))
    ;; (before-push-pose)
    ;; (make-reset-pose)
    (if (> move_rot 45)  ;; to move demo more correct
	(setq move_len (- move_len 100)))
    (go-vel-rotate move_rot)
    (rotate-ref-wall move_rot (deg2rad 10))
    (go-vel-linear (/ move_len 1000.0) 2)
    (when *pass-to-human-flag*
      (go-vel-rotate (* -1 move_rot))
      (pass-decoration)
      (ros::duration-sleep 7.0))
    (make-reset-pose)
    (if (not *pass-to-human-flag*)
	(go-vel-rotate (* -1 move_rot)))
    (rotate-ref-wall 0.0 (deg2rad 10))
    (setq wall_x (get-distance-wall 320 240))
    (format t "wall_x: ~A, *wall-x*: ~A~%" wall_x *wall-x*)
    (go-vel-linear (/ (- wall_x *wall-x*) 1000.0) 1)
    ))

(defun place-balloon ()
  (let* ((place_pos (elt *place-pos-lst* *catch-box-num*))
	 (close_len_rot))
    (setq close_len_rot (place-balloon-manip place_pos))
    (if (not *pass-to-human-flag*)
	(repush-balloon))
    (go-back (elt close_len_rot 0) (elt close_len_rot 1) (elt close_len_rot 2) (elt close_len_rot 3))
    ))

