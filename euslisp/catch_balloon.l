#!/usr/bin/env roseus

(setq *CATCH-X-OFFSET* 200)
(setq *CATCH-Z-OFFSET* 50)
(setq *CATCH-BALLOON-TH* 0.2)

(defun get-closest-box ()
  (let* ((pos) (xpos_lst '()) (closest_x) (closest_num 0) (center_box_info))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (setq xpos_lst (append xpos_lst (list (elt pos 0)))))
    (setq xpos_lst (sort xpos_lst #'<=))
    (setq closest_x (elt xpos_lst 0))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (when (= (elt pos 0) closest_x)
	(setq closest_num i)
	(setq closest_pos pos)))
    (format t "cbox ~A: ~A~%" closest_num closest_pos)
    (setq center_box_info (get-center-box))
    (when (< (abs (- (elt (elt center_box_info 1) 0) (elt closest_pos 0))) 100)
      (setq closest_num (elt center_box_info 0))
      (setq closest_pos (elt center_box_info 1)))
    (format t "cbox ~A: ~A~%" closest_num closest_pos)
    (list closest_num closest_pos))
  )

(defun get-center-box ()
  (let* ((center_num 0) (ypos_lst '()) (pos) (center_pos) (center_y))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (setq ypos_lst (append ypos_lst (list (elt pos 1)))))
    (setq ypos_lst (sort ypos_lst #'<=))
    (setq center_y (elt ypos_lst (/ (length ypos_lst) 2)))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (when (= (elt pos 1) center_y)
	(setq center_num i)
	(setq center_pos pos)))
    ;; (format t "center_num ~A~%" center_num)
    ;; (format t "center_pos ~A~%" center_pos)
    (list center_num center_pos))
  )

(defun set-before-catch-pose ()
  (inv-from-reset-pose #f(550 100 500))
  (send *fetch* :rarm :wrist-r :joint-angle -34.22)
  ;; (send-robot 4000)
  (send *ri* :stop-grasp)
  )

(defun catch-balloon-manip (thresh)
  ;; thresh: diff between ideal and real [cm]
  (let* ((diff_width 0)
	 (real_width)
	 (ideal_width 0.1)
	 (grasp-result))
    (while (and (< diff_width thresh) (> ideal_width 0))
      (setq ideal_width (- ideal_width 0.01))
      (setq grasp-result (send *ri* :go-grasp :pos ideal_width))
      (ros::duration-sleep 0.7)
      (setq real_width (send grasp-result :position))
      (setq diff_width (- real_width ideal_width))
      (format t "ideal: ~A, real: ~A~%" ideal_width real_width)
      (format t "diff_width: ~A~%" diff_width)
      )
    ))

(defun before-push-pose ()
  (inv-from-reset-pose #f(400 -400 450))
  (send *fetch* :rarm :wrist-p :joint-angle 9)
  (send *fetch* :rarm :elbow-p :joint-angle 120)
  (send *fetch* :rarm :move-end-pos #f(300 0 0) :world)
  (send-robot 4000)
  (send *fetch* :rarm :move-end-pos #f(0 300 100) :world)
  (send-robot 3000)
  ;; (get-arm-end-pos) -> #f(399.369 -313.6 860.035)
  )

(defun before-catch (cbox_num cbox_pos)
  (let* ((cbox_num cbox_num)
	 (cbox_pos cbox_pos)
	 (arm_end_pos) (move_y) (ik_res t)
	 (close_deco_vec))
    (go-vel-linear (/ -500 1000.0) 1)
    (set-before-catch-pose)
    (setq arm_end_pos (get-arm-end-pos))
    (format t "cbox_pos ~A~%" cbox_pos)
    (format t "arm_end_pos ~A~%" arm_end_pos)
    (send *fetch* :torso :waist-z :joint-angle
	  (+ (+ (- (elt cbox_pos 2) (elt arm_end_pos 2))
		(send *fetch* :torso :waist-z :joint-angle))
	     *CATCH-Z-OFFSET*))
    (send-robot 4000)
    (setq close_deco_vec
	  (float-vector (- (+ (elt cbox_pos 0) 500) (elt arm_end_pos 0))
			(- (elt cbox_pos 1) (elt arm_end_pos 1)) 0))
    (format t "go-vel-rotate ~A~%"
	    (* 180 (/ (atan (/ (elt close_deco_vec 1) (elt close_deco_vec 0))) pi)))
    (go-vel-rotate (atan (/ (elt close_deco_vec 1) (elt close_deco_vec 0))))
    (format t "go-vel-linear ~A~%" (- (norm close_deco_vec) *CATCH-X-OFFSET*))
    (go-vel-linear (/ (- (norm close_deco_vec) *CATCH-X-OFFSET*) 1000.0) 1)
    (send *fetch* :rarm :move-end-pos (float-vector *CATCH-X-OFFSET* 0 0) :world)
    (send-robot 2000)
    (if (< (- (elt cbox_pos 1) (elt arm_end_pos 1)) 0)
	(setq move_y -200)
      (setq move_y 200))
    (setq ik_res (send *fetch* :rarm :move-end-pos (float-vector 0 move_y 0) :world))
    (while (not ik_res)
      (if (< move_y 0)
	  (setq move_y (+ move_y 50))
	(setq move_y (- move_y 50)))
      (setq ik_res (send *fetch* :rarm :move-end-pos (float-vector 0 move_y 0) :world)))
    (send-robot 2000)
    close_deco_vec)
  )

(defun after-catch (close_deco_vec)
  (let* ((wall_x) (rot_num)
	 (close_deco_vec close_deco_vec)
	 (move_len (* -1 (norm close_deco_vec)))
	 (move_rot (* -1 (atan (/ (elt close_deco_vec 1) (elt close_deco_vec 0))))))
    (format t "go-vel-linear ~A~%" move_len)
    (go-vel-linear (/ move_len 1000.0) 1)
    (format t "go-vel-rotate ~A~%" (* 180 (/ move_rot pi)))
    (go-vel-rotate move_rot)
    (before-push-pose)
    (format t "*close-deco-x*: ~A~%" *close-deco-x*)
    (go-vel-linear (* -1 (/ (- *close-deco-x* 500) 1000.0)) 1)
    (setq rot_num (- (floor (/ *rotate-rad* (/ pi 4))) 1))
    (format t "rot_num ~A~%" rot_num)
    (dotimes (i rot_num)
      (go-vel-rotate (* -1 (/ pi 4))))
    (rotate-ref-wall)
    (setq wall_x (get-distance-wall 320 240))
    (format t "wall_x: ~A, *wall-x*: ~A~%" wall_x *wall-x*)
    (go-vel-linear (/ (- wall_x *wall-x*) 1000.0) 1)
    ))

(defun catch-balloon ()
  (let* ((cbox_num_pos (get-closest-box))
	 (cbox_pos (elt cbox_num_pos 1))
	 (close_deco_vec))
    (setq *catch-box-num* (elt cbox_num_pos 0))
    (setq close_deco_vec (before-catch *catch-box-num* cbox_pos))
    (catch-balloon-manip *CATCH-BALLOON-TH*)
    (after-catch close_deco_vec)
    ))
