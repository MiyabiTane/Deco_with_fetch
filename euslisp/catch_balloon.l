#!/usr/bin/env roseus

(setq *CATCH-BALLOON-TH* 0.05)

(defun get-closest-box ()
  (let* ((pos) (xpos_lst '()) (closest_x) (closest_num 0) (center_box_info))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (setq xpos_lst (append xpos_lst (list (elt pos 0)))))
    (setq xpos_lst (sort xpos_lst #'<=))
    (setq closest_x (elt xpos_lst 0))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (when (= (elt pos 0) closest_x)
	(setq closest_num i)
	(setq closest_pos pos)))
    (format t "cbox ~A: ~A~%" closest_num closest_pos)
    (setq center_box_info (get-center-box))
    (when (< (abs (- (elt (elt center_box_info 1) 0) (elt closest_pos 0))) 100)
      (setq closest_num (elt center_box_info 0))
      (setq closest_pos (elt center_box_info 1)))
    (format t "cbox ~A: ~A~%" closest_num closest_pos)
    (list closest_num closest_pos))
  )

(defun get-center-box ()
  (let* ((center_num 0) (ypos_lst '()) (pos) (center_pos) (center_y))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (setq ypos_lst (append ypos_lst (list (elt pos 1)))))
    (setq ypos_lst (sort ypos_lst #'<=))
    (setq center_y (elt ypos_lst (/ (length ypos_lst) 2)))
    (dotimes (i (length *catch-pos-lst*))
      (setq pos (elt *catch-pos-lst* i))
      (when (= (elt pos 1) center_y)
	(setq center_num i)
	(setq center_pos pos)))
    ;; (format t "center_num ~A~%" center_num)
    ;; (format t "center_pos ~A~%" center_pos)
    (list center_num center_pos))
  )

(defun set-before-catch-pose ()
  (inv-from-reset-pose #f(550 100 500))
  (send *fetch* :rarm :wrist-r :joint-angle -34.22)
  ;; (send-robot 4000)
  ;; (send *ri* :stop-grasp)
  ;; arm_end_pos #f(550.048 100.282 500.078)
  )

(defun catch-balloon-manip (thresh retry_count)
  ;; thresh: diff between ideal and real [cm]
  (let* ((diff_width 0)
	 (real_width)
	 (ideal_width 0.1)
	 (grasp-result)
	 (retry_count retry_count))
    (while (and (< diff_width thresh) (> ideal_width 0))
      (setq ideal_width (- ideal_width 0.01))
      (setq grasp-result (send *ri* :go-grasp :pos ideal_width))
      (ros::duration-sleep 0.7)
      (setq real_width (send grasp-result :position))
      (setq diff_width (- real_width ideal_width))
      (format t "ideal: ~A, real: ~A~%" ideal_width real_width)
      (format t "diff_width: ~A~%" diff_width)
      )
    (when (and (< real_width 0.01) (< retry_count 2)) ;; ask for help from human
      (send *ri* :stop-grasp)
      (format t "風船を掴むのに失敗しました~%")
      (send *ri* :speak-jp "風船を掴めませんでした。もう一度渡してもらえますか？")
      (send *fetch* :rarm :move-end-pos #f(0 0 100) :world)
      (send-robot 1000)
      (ros::duration-sleep 7)
      (catch-balloon-manip *CATCH-BALLOON-TH* (+ retry_count 1)))
    ideal_width)
  )

(defun before-push-pose ()
  (inv-from-reset-pose #f(400 -400 450))
  (send *fetch* :rarm :wrist-p :joint-angle 9)
  (send *fetch* :rarm :elbow-p :joint-angle 120)
  (send *fetch* :rarm :move-end-pos #f(300 0 0) :world)
  (send-robot 4000)
  (send *fetch* :rarm :move-end-pos #f(0 300 100) :world)
  (send-robot 3000)
  ;; (get-arm-end-pos) -> #f(399.369 -313.6 860.035)
  )

(defun listen-cb (msg)
  (if (> (length (send msg :transcript)) 0)
      (setq listen_flag 1))
  )

(defun catch-interact ()
  (switch-chat-mode t)
  (format t "その風船を渡して下さい~%")
  (send *ri* :speak-jp "その風船を渡してくれませんか？渡し終わったら声をかけてくださいね")
  (setq listen_flag 0)
  (ros::subscribe "/speech_to_text"
		  speech_recognition_msgs::SpeechRecognitionCandidates #'listen-cb)
  (while (= listen_flag 0)
    (ros::spin-once)
    (ros::sleep))
  (ros::unsubscribe "/speech_to_text")
  (format t "ありがとうございます~%")
  (send *ri* :speak-jp "ありがとうございます")
  (switch-chat-mode nil)
  )

(defun before-catch (cbox_pos)
  (let* ((cbox_pos cbox_pos)
	 (arm_end_pos)
	 (move_y))
    (go-vel-linear (/ -150 1000.0) 1)
    (setq *close-deco-x* (- *close-deco-x* 150))
    (setq cbox_pos (v+ cbox_pos #f(150 0 0)))
    (send *ri* :stop-grasp)
    (set-before-catch-pose)
    (setq arm_end_pos (get-arm-end-pos))
    (send *fetch* :torso :waist-z :joint-angle
	  (+ (+ (- (elt cbox_pos 2) (elt arm_end_pos 2))
		(send *fetch* :torso :waist-z :joint-angle) 50)))
    (send-robot 4000)
    (setq move_y (- (elt cbox_pos 1) (elt arm_end_pos 1)))
    (setq ik_res (send *fetch* :rarm :move-end-pos (float-vector 0 move_y 0) :world))
    (while (not ik_res)
      (if (< move_y 0)
	  (setq move_y (+ move_y 50))
	(setq move_y (- move_y 50)))
      (setq ik_res (send *fetch* :rarm :move-end-pos (float-vector 0 move_y 0) :world)))
    (format t "move_y: ~A~%" move_y)
    (send-robot 1000)
    (send *fetch* :rarm :move-end-pos #f(100 0 0) :world)
    (send *fetch* :head :look-at (get-arm-end-pos))
    (send-robot 1000)
    (catch-interact)
    (ros::duration-sleep 1.0)
    ))

(defun after-catch (hand_width)
  (let* ((wall_x)
	 (leave_x (* -1 *close-deco-x*))
	 (hand_width hand_width))
    (go-vel-linear (/ -200 1000.0) 1)
    (set-before-catch-pose)
    (send-robot 4000)
    (before-push-pose)
    (setq leave_x (+ leave_x 200))
    (format t "leave_x: ~A~%" leave_x)
    (go-vel-linear (/ leave_x 1000.0) 1)
    (format t "rot_num: ~A~%" *find-rot-num*)
    (dotimes (i *find-rot-num*)
      (go-vel-rotate (* -1 (/ pi 4))))
    (ros::duration-sleep 1.0)
    (rotate-ref-wall 0.0 *wall-rotate-rad*)
    (setq wall_x (get-distance-wall 320 240))
    (format t "wall_x: ~A, *wall-x*: ~A~%" wall_x *wall-x*)
    (go-vel-linear (/ (- wall_x *wall-x*) 1000.0) 1)
    ))

(defun catch-balloon ()
  (let* ((cbox_num_pos (get-closest-box))
	 (cbox_pos (elt cbox_num_pos 1))
	 (hand_width))
    (setq *catch-box-num* (elt cbox_num_pos 0))
    (before-catch cbox_pos)
    (setq hand_width (catch-balloon-manip *CATCH-BALLOON-TH* 0))
    (after-catch hand_width)
    ))
