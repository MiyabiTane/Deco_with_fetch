#!/usr/bin/env roseus

(setq *PLACE-POS-OFFSET* #f(1000 -313.6 0))
(setq *PUSH-X-OFFSET* 0)

(defun inv-from-reset-pose (target_pos)
  (send *fetch* :reset-pose)
  (setq target_coords (make-coords :pos target_pos))
  (send *fetch* :inverse-kinematics target_coords)
  (send *fetch* :head :look-at *look-at-pos*)
  )

(defun get-distance-wall (x y)
  (let* ((x x) (y y) (wall_x) (wall_pcl))
    (ros::duration-sleep 1.0)
    (setq wall_pcl (one-shot-subscribe *head-camera-points*
				       sensor_msgs::PointCloud2 :after-stamp (ros::time-now)))
    (convert-2D->3D x y wall_pcl)
    (convert-2D->3D x y wall_pcl) ;; to get more correct value
    (setq wall_x (elt result_3d_pos 0))
    (format t "wall_x: ~A~%" wall_x)
    wall_x)
  )

(defun before-catch-pose ()
  (inv-from-reset-pose #f(550 100 500))
  (send *fetch* :rarm :wrist-r :joint-angle -34.22)
  (send-robot 4000)
  (send *ri* :stop-grasp)
  )

(defun before-push-pose ()
  (inv-from-reset-pose #f(400 -400 450))
  (send *fetch* :rarm :wrist-p :joint-angle 9)
  (send *fetch* :rarm :elbow-p :joint-angle 120)
  ;; (send *fetch* :rarm :wrist-r :joint-angle 92.7005)
  (send *fetch* :rarm :move-end-pos #f(300 0 0) :world)
  (send-robot 4000)
  (send *fetch* :rarm :move-end-pos #f(0 300 100) :world)
  (send-robot 3000)
  ;; (get-arm-end-pos) -> #f(399.369 -313.6 860.035)
  ;; (send *fetch* :rarm :wrist-r :joint-angle
  ;;	(+ 180 (send *fetch* :rarm :wrist-r :joint-angle)))
  ;;  (send-robot 1000)
  )

(defun catch-balloon (thresh)
  ;; thresh: diff between ideal and real [cm]
  (let* ((diff_width 0)
	 (real_width)
	 (ideal_width 0.1)
	 (grasp-result))
    (while (and (< diff_width thresh) (> ideal_width 0))
      (setq ideal_width (- ideal_width 0.01))
      (setq grasp-result (send *ri* :go-grasp :pos ideal_width))
      (ros::duration-sleep 0.7)
      (setq real_width (send grasp-result :position))
      (setq diff_width (- real_width ideal_width))
      (format t "ideal: ~A, real: ~A~%" ideal_width real_width)
      (format t "diff_width: ~A~%" diff_width)
      )
    ))

(defun push-balloon (thresh1 thresh2)
  ;; thresh: diff between ideal and real [mm]
  (let* ((diff_x 0)
	 (real_x (elt (get-arm-end-pos) 0))
	 (ideal_x real_x)
	 (diff_wall_x 0)
	 (init_wall_x (get-distance-wall 320 240))
	 (real_wall_x init_wall_x))
    (while (and (< diff_x thresh1) (< diff_wall_x thresh2))
      (send *fetch* :rarm :move-end-pos #f(20 0 0) :world)
      (send-robot 1000)
      (setq ideal_x (+ ideal_x 20))
      (setq real_x (elt (get-arm-end-pos) 0))
      (setq diff_x (- ideal_x real_x))
      (format t "diff_x: ~A~%" diff_x)
      (setq real_wall_x (get-distance-wall 320 240))
      (setq diff_wall_x (- real_wall_x init_wall_x))
      (format t "diff_wall_x ~A~%" diff_wall_x)
      (if (< (- real_wall_x init_wall_x) -500)  ;; remove bug
	  (setq init_wall_x real_wall_x)))
    ))

(defun place-balloon-manip (place_pos)
  (let* ((place_pos (float-vector *wall-x* (elt place_pos 1) (elt place_pos 2)))
	 (place_pos (v- place_pos *PLACE-POS-OFFSET*))
	 (move_rot (atan (/ (elt place_pos 1) (elt place_pos 0))))
	 (move_len (norm (v- place_pos (float-vector 0 0 (elt place_pos 2)))))
	 (wall_distance)
	 (arm_end_pos)
	 (torso_z)
	 (rarm_up 0))
    (format t "place pos: ~A~%" place_pos)
    (format t "move_rot: ~A, move_len: ~A~%" (/ (* 180.0 move_rot) pi) move_len)
    (go-vel-rotate move_rot)
    (go-vel-linear (/ move_len 1000.0) 2)
    (setq arm_end_pos (get-arm-end-pos))
    (send *fetch* :head :look-at  ;; for rotate-ref-wall
	  (v+ *look-at-pos* (float-vector 0 (+ (elt arm_end_pos 1) 100) 0)))
    (send-robot 1000)
    (ros::duration-sleep 0.5)
    (rotate-ref-wall)
    (setq torso_z (send *fetch* :torso :waist-z :joint-angle))
    (if (< (- (elt place_pos 2) (elt arm_end_pos 2)) 0)
	(setq rarm_up (- (elt place_pos 2) (elt arm_end_pos 2)))
      (progn
	(if (> (- (elt place_pos 2) (elt arm_end_pos 2)) (- 386.15 torso_z))  ;; max 386.15
	    (setq rarm_up (- (- (elt place_pos 2) (elt arm_end_pos 2)) (- 386.15 torso_z)))
	  (setq rarm_up 0))
	(send *fetch* :torso :waist-z :joint-angle
	      (+ torso_z (- (elt place_pos 2) (elt arm_end_pos 2))))
	(format t "torso z: ~A, torso up ~A~%" torso_z (- (elt place_pos 2) (elt arm_end_pos 2)))
	(send-robot 2000)))
    (go-vel-linear (/ *PUSH-X-OFFSET* 1000.0) 1)
    (format t "rarm_up: ~A~%" rarm_up)
    (send *fetch* :rarm :move-end-pos (float-vector 50 0 rarm_up) :world)
    (send-robot 3000)
    (push-balloon 0.2 10.0)
    (format t "finish push~%")
    (send *ri* :stop-grasp)
    (send *fetch* :rarm :move-end-pos #f(-50 0 0) :world)
    (send-robot 2000)
    (send *fetch* :rarm :move-end-pos #f(0 0 -150) :world)
    (send-robot 2000)
    (send *fetch* :rarm :move-end-pos #f(-150 0 0) :world)
    (send-robot 2000)
    place_pos)
  )

(defun repush-balloon ()
  (send *fetch* :rarm :move-end-pos #f(0 0 150) :world)
  (send-robot 2000)
  (send *fetch* :rarm :move-end-pos #f(50 0 0) :world)
  (send-robot 2000)
  (push-balloon 0.2 10.0)
  (send *fetch* :rarm :move-end-pos #f(-100 0 0) :world)
  (send-robot 2000)
  (go-vel-linear (* -1 (/ *PUSH-X-OFFSET* 1000.0)) 1)
  (make-reset-pose)
  )

(defun go-back (go_back_pos)
  (let* ((go_back_pos (float-vector (elt go_back_pos 0) (elt go_back_pos 1) 0))
	 (move_len (* -1 (norm go_back_pos)))
	 (move_rot (atan (/ (elt go_back_pos 1) (elt go_back_pos 0))))
	 (wall_x))
    (format t "go_back_pos: ~A~%" go_back_pos)
    (format t "move_len: ~A~%, move_rot: ~A~%" move_len (/ (* 180.0 move_rot) pi))
    (go-vel-rotate move_rot)
    (go-vel-linear (/ move_len 1000.0) 2)
    (rotate-ref-wall)
    (setq wall_x (get-distance-wall 320 240))
    (format t "wall_x: ~A, *wall-x*: ~A~%" wall_x *wall-x*)
    (go-vel-linear (/ (- wall_x *wall-x*) 1000.0) 1)
    ))

(defun push-balloon-main ()
  (send *fetch* :head :look-at *look-at-pos*)
  (send-robot 4000)
  ;; set goal_pos
  (setq *wall-x* (get-distance-wall 320 240))
  (setq place_pos (float-vector *wall-x* 50 1000))
  (format t "place_pos: ~A~%" place_pos)
  (before-catch-pose)
  (send *ri* :speak-jp "風船を渡して下さい")
  (format t "風船を渡して下さい~%")
  (ros::duration-sleep 5.0)
  (catch-balloon 0.02)
  (before-push-pose)
  (setq go_back_pos (scale -1.0 (place-balloon-manip place_pos)))
  (repush-balloon)
  (go-back go_back_pos)
  )

(defun catch-test ()
  (send *ri* :stop-grasp)
  (ros::duration-sleep 2)
  (before-catch-pose)
  (send *ri* :speak-jp "風船を渡して下さい")
  (ros::duration-sleep 5.0)
  (catch-balloon 0.015)
  (before-push-pose)
  (send *fetch* :rarm :move-end-pos #f(0 300 100) :world)
  (send-robot 3000)
  )

;; ... memo ... 
;; (send *ri* :stop-grasp)
;; (send *ri* :go-grasp :pos 0.05)
;; (send *ri* :gripper :position)
;; (send *fetch* :rarm :move-end-pos #f(0 0 10) :world)


;; after-catch
;; (send *fetch* :reset-pose)
;; (setq target_pos (make-coords :pos #f(800 0 600)))
;; (send *fetch* :inverse-kinematics target_pos)
