#!/usr/bin/env roseus

(setq *suggest-req-topic* "/suggest_place_pos")
(setq *suggest-listen-topic* "/is_suggest")
(setq *bounding-box-not-plane* "/cluster_decomposer_not_plane/boxes")
;; (setq *bounding-box-not-plane* "/segmentation_decomposer/boxes")

(defun suggest-if-asked (check_time)
  (let* ((begin_time (ros::time-now))
	 (end_time begin_time)
	 (elapsed_time 0)
	 (cur_will_val *HUMAN-WILL-VAL*))
    (send *fetch* :rarm :move-end-pos #f(0 0 20) :world)
    (send-robot 2000)
    (format t "-- wait ~A seconds for suggest --~%" check_time)
    (ros::subscribe *suggest-listen-topic* std_msgs::Bool #'suggest-cb)
    (while (and (= *HUMAN-WILL-VAL* cur_will_val) (< elapsed_time check_time))
      (ros::spin-once)
      (ros::sleep)
      (setq end_time (ros::time-now))
      (setq elapsed_time (- (send end_time :sec) (send begin_time :sec))))
    (ros::unsubscribe *suggest-listen-topic*)
    ))

(defun suggest-cb (msg)
  (when (send msg :data)
    (suggest-to-human-manip)
    (setq *HUMAN-WILL-VAL* (max 0.0 (- *HUMAN-WILL-VAL* 0.2)))
    (format t "*HUMAN-WILL-VAL*: ~A~%" *HUMAN-WILL-VAL*)
    ))

(defun find-boxes-suggest (supposed_pos arm_end_pos)
  (let* ((bboxes_msg) (box_msg) (box_cd) (box_pos)
	 (pos_distance) (min_distance 10000) (found_box_msg)
	 (bboxes_msg (instance jsk_recognition_msgs::BoundingBoxArray :init)))
    (ros::duration-sleep 5.0)
    (while (< (length (send bboxes_msg :boxes)) 2)
      (setq bboxes_msg (one-shot-subscribe *bounding-box-not-plane*
					   jsk_recognition_msgs::BoundingBoxArray
					   :after-stamp (ros::time-now))))
    (dotimes (i (length (send bboxes_msg :boxes)))
      (setq box_msg (elt (send bboxes_msg :boxes) i))
      (setq box_cd (bbox->lst box_msg))
      (setq box_pos (send (elt box_cd 0) :pos))
      (setq pos_distance (norm (v- (v- supposed_pos (float-vector 0 0 (elt supposed_pos 2)))
				   (v- box_pos (float-vector 0 0 (elt box_pos 2))))))
      (format t "pos_distance: ~A, box_pos: ~A, box_dims: ~A~%" pos_distance box_pos (elt box_cd 1))
      (when (< pos_distance min_distance)
	(when (and (and (> (norm (v- box_pos arm_end_pos)) 300)
			(> (norm (elt box_cd 1)) 100))
		   (< (abs (elt box_pos 1)) 300))
	  (format t "pos_distance: ~A, min_distance: ~A~%" pos_distance min_distance)
	  (setq min_distance pos_distance)
	  (setq found_box_msg box_msg)))
      )
    found_box_msg)
  )

(defun suggest-by-pointing (result_msg)
  (let* ((matched_num) (ideal_pos))
    ;; (format t "suggest result ~A~%" result_msg)
    (if (not (send result_msg :ideal_deco_uv))
	(send *ri* :speak-jp "すみません、思いつきませんでした~%")
      (progn
	(setq matched_num (floor (send (elt (send result_msg :ideal_deco_uv) 0) :z)))
	(setq ideal_pos (elt *place-pos-lst* matched_num))
	(format t "num: ~A, pos: ~A~%" matched_num ideal_pos)
	(pointing-pos ideal_pos)
	(format t "あそこが良いと思います~%")
	(send *ri* :speak-jp "あそこに置くのが良いと思います")
	(ros::duration-sleep 3.0)))
    (before-push-pose)
    ))

(defun suggest-to-human-manip ()
  (let* ((arm_end_pos) (box_cd) (box_pos) (box_dims) (xs_ys_lst)
	 (suggest-req-msg (instance deco_with_fetch::DecoStatusRequest :init))
	 (rec_uv_msg (instance jsk_recognition_msgs::PlotData :init))
	 (image_raw_msg) (result_msg) (look_at_pos))
    (set-before-catch-pose)
    ;; (send *fetch* :torso :waist-z :joint-angle torso_z)
    (setq look_at_pos (v+ (get-arm-end-pos) #f(400 0 0)))
    (send *fetch* :head :look-at look_at_pos)
    (send-robot 4000)
    (send *ri* :speak-jp "その風船")
    (send *ri* :speak-jp "よく見せてくれませんか？")
    (format t "風船を見せて下さい~%")
    (ros::duration-sleep 3.0)
    (setq box_msg (find-boxes-suggest look_at_pos (get-arm-end-pos)))
    (while (not box_msg)
      (format t "風船を見せて下さい~%")
      (send *ri* :speak-jp "もう一度見せてくれませんか？")
      (ros::duration-sleep 3.0)
      (setq box_msg (find-boxes-suggest look_at_pos (get-arm-end-pos))))
    (send *ri* :speak-jp "ありがとうございます")

    (setq image_raw_msg
	  (one-shot-subscribe *head-camera-img*
			      sensor_msgs::Image :after-stamp (ros::time-now)))
    (send suggest-req-msg :back_img image_raw_msg)

    (setq box_cd (bbox->lst box_msg))
    (setq box_pos (send (elt box_cd 0) :pos))
    (setq box_dims (elt box_cd 1))
    ;; (format t "pos: ~A, dims: ~A~%" box_pos box_dims)
    (setq xs_ys_lst (get-corner-uv box_pos box_dims))
    ;; (format t "xs_ys_lst: ~A~%" xs_ys_lst)
    (send rec_uv_msg :xs (elt xs_ys_lst 0))
    (send rec_uv_msg :ys (elt xs_ys_lst 1))
    (send suggest-req-msg :decos_rec_uv (list rec_uv_msg))

    (send suggest-req-msg :deco_count *deco-loop-num*)
    (send suggest-req-msg :box_num *catch-box-num*)

    (print-suggest-pub-info suggest-req-msg)
    (format t "wating service ...~%")
    (ros::wait-for-service *suggest-req-topic*)
    (setq result_msg (ros::service-call *suggest-req-topic* suggest-req-msg))
    (format t "got service result~%")

    (suggest-by-pointing result_msg)
    ))

(defun print-suggest-pub-info (req-msg)
  (format t "~%")
  (format t "- deco_count ~A~%" (send req-msg :deco_count))
  (format t "- box_num ~A~%" (send req-msg :box_num))
  (when (> (length (send req-msg :decos_rec_uv)) 0)
    (format t "- deco_rec_uv xs: ~A~%" (send (elt (send req-msg :decos_rec_uv) 0) :xs))
    (format t "- deco_rec_uv ys: ~A~%" (send (elt (send req-msg :decos_rec_uv) 0) :ys)))
  )
